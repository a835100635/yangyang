<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" />
  <link rel="stylesheet" href="index.css">
  <script src="https://unpkg.com/vue@3.2.12/dist/vue.global.js"></script>
  <script src="./utils/audio.js"></script>
  <title></title>
</head>
<body>
  <div id="app">
    <h1>ç¬¬ {{ level }} å…³</h1>
    <header>
      <span class="btn" @click="handleStart">å¼€å§‹æ¸¸æˆ</span>
      <span class="btn" @click="handleReset">é‡ç½®</span>
      <span class="btn" @click="handleSwitch('prev')">ä¸Šä¸€å…³</span>
      <span class="btn" @click="handleSwitch('next')">ä¸‹ä¸€å…³</span>
      <p class="center">
        è¡Œ: 
        <select v-model="config.row">
          <option :value ="item" v-for="item in [3,4,5,6,7,8]">{{ item }}</option>
        </select>
        åˆ—: 
        <select v-model="config.col">
          <option :value ="item" v-for="item in [3,4,5,6,7,8]">{{ item }}</option>
        </select>
      </p>
    </header>
    <!-- å®¹å™¨ -->
    <div class="wrap">
      <div class="container" :style="setContainerStyle()">
        <div class="card-wrap"
          v-for="(item, index) in cards" 
          :key="index"  
          :style="setCardStyle(item)">
          <div class="card" 
            :class="[item.not && 'is-allow', item.id]"
            :style="setAnimation(item)"
            @click="clickCard(item, index)"
          >
            <span>{{ item.icon }}</span>
          </div>
        </div>
      </div>
    </div>
    <!-- å¡æ§½ -->
    <div class="card-slot"></div>
  </div>
  <script>
    const { reactive, ref, toRefs, setup, computed, onMounted, watch } = Vue;
    const App = {
      setup() {
        // åˆå§‹åŒ–éŸ³ä¹æ§ä»¶
        const audio = new CustomAudio({
          template: '#app',
          bgmSrc: './static/bgm.mp3',
          clickBgm: './static/clickBgm.mp3'
        });
        window.customAudio = audio;
        /**
         * å®¹å™¨æ ·å¼
         */
        const setContainerStyle = () => {
          const { base, row, col } = config;
          return `height: ${base * row}px; width: ${base * col}px`;
        }
        /**
         * è®¾ç½®å¡ç‰‡ä½ç½®
         */
        const setCardStyle = ({ x, y }) => {
          return `
            transform: translateX(${x}px) translateY(${y}px);
          `;
        }
        /**
         * è®¾ç½®å¡ç‰‡åŠ¨ç”»
         */
        const setAnimation = ({ id, clear, display }) => {
          let isClear = ''
          if(clear) {
            isClear = `animation: scaleDraw ${config.animationTime}ms;`
          }
          if(display) {
            isClear += 'display: none;';
          }
          return isClear;
        }
        
        /**
         * éšæœºç”ŸæˆæŒ‡å®šé•¿åº¦id
         */
        const randomCreateId = (length) => {
            return (Math.random() + new Date().getTime()).toString(32).slice(0,length);
        }

        onMounted(() => {
          getDoMInfo();
        })
        const getDoMInfo = () => {
          const containerDom = document.querySelector('.container');
          data.containerInfo = containerDom.getBoundingClientRect();
          const cardSlotDom = document.querySelector('.card-slot');
          data.cardSlotInfo = cardSlotDom.getBoundingClientRect();
        }

        // é…ç½®é¡¹
        const config = reactive({
          // ä¸å¡ç‰‡å®½åº¦ä¸€è‡´
          base: 40,
          // å¡æ§½ä¸­æœ€é•¿å¡ç‰‡é•¿åº¦
          selectMaxLength: 7,
          // å¡æ§½è®¾å®šå¤šå°‘ä¸ªç›¸åŒå¡ç‰‡å°±æ¶ˆæ‰
          maxCount: 3,
          // åŠ¨ç”»æ—¶é—´ æ¯«ç§’
          animationTime: 400,
          // æœ€å¤§å…³æ•°
          maxLevel: 10,
          // è¡Œ
          row: 8,
          // åˆ—
          col: 8
        });

        const data = reactive({
          level: 1,
          cards: [],
          select: new Map(),
          containerInfo: null,
          cardSlotInfo: null
        });

        /**
         * ç­‰çº§åˆ‡æ¢ é‡ç½®æ¸¸æˆ 
         */
        watch(() => data.level, () => {
          handleReset();
        });
        watch(() => config.row, () => {
          getDoMInfo();
          data.select.clear();
          data.cards = [];
        });
        watch(() => config.col, () => {
          getDoMInfo();
          data.select.clear();
          data.cards = [];
        });

        /**
         * å¡æ§½å·²å­˜åœ¨å¡ç‰‡é•¿åº¦
         */
        const selectLength = computed(() => {
          let length = 0;
          data.select.forEach((item) => {
            length += item.length;
          })
          return length;
        });

        /**
         * å¡ç‰‡é»˜è®¤å›¾æ ‡
         */
        const defaultIcons = ['ğŸ‘', 'ğŸŒ¹', 'ğŸ–', 'ğŸš', 'ğŸ‘“', 'ğŸ­', 'ğŸ˜˜', 'ğŸ‘', 'â­', 'ğŸ’©', 'ğŸ’Š', 'ğŸˆ'];
        /**
         * æ ¹æ®ç­‰çº§é€‰æ‹©å¡ç‰‡å›¾æ ‡çš„å¤šç§é€‰æ‹©
         */
        const icons = computed(() => {
          return defaultIcons.slice(0, 2 * data.level);
        });

        /**
         * å¡ç‰‡é»˜è®¤åç§»å€¼ éšæ„è®¾å®š
         */
        const defaultOffsetValue = [7, -7, 20, -20, 25, -25, 33, -33, 40, -40];
        const defaultOffsetValueLength = defaultOffsetValue.length;

        /**
         * å¡ç‰‡é»˜è®¤ç”Ÿæˆ3çš„å€æ•° ä¸æ˜¯3çš„å€æ•°çš„åˆ™ä¸å¯èƒ½é€šå…³
         */
        const defaultRounds = [3, 6, 9, 3, 6, 3, 3, 6, 3];


        /**
         * åˆå§‹åŒ–
         */
        const init = () => {
          console.log('init game--->', icons.value);
          data.select.clear();
          for(const i in icons.value) {
            // éšæœº3çš„å€æ•°
            const rounds = defaultRounds[Math.floor(Math.random() * defaultRounds.length)];
            for(let k = 0; k < rounds; k++) {
              createCardInfo(icons.value[i]);
            }
          }
          checkShading();
        }

        /**
         * åˆ›å»ºå¡ç‰‡å±æ€§
         * id icon x y ã€‚ã€‚ã€‚
         */
        const createCardInfo = (icon) => {
          // åç§»
          const offset = defaultOffsetValue[Math.floor(defaultOffsetValueLength * Math.random())];
          // éšæœº8åˆ— 8è¡Œ
          const row = Math.floor(Math.random() * config.row);
          const col = Math.floor(Math.random() * config.col);

          let x = col * config.base + offset;
          let y = row * config.base + offset;
          
          data.cards.push({
            id: randomCreateId(6),
            icon,
            x,
            y,
            // æ§åˆ¶é®ç½©å±‚
            not: true,
            // æ˜¯å¦åœ¨å¡æ§½ä¸­ 0å¦ 1æ˜¯
            status: 0,
            // æ˜¯å¦æ¸…é™¤
            clear: false,
            // éšè—
            display: false
          })
        }

        /**
         * æ˜¯å¦èƒ½ç‚¹å‡» æ˜¯å¦æœ‰é˜´å½±
         */
        const checkShading = () => {
          const cards = data.cards;
          for (let i = 0; i < cards.length; i++) {
            const cur = cards[i];
            cur.not = true;
            // å·²æ¶ˆå®Œå¡ç‰‡å’Œåœ¨å¡æ§½å†…çš„å¡ç‰‡è·³è¿‡
            if (cur.status !== 0 || cur.display) continue;
            const { x: x1, y: y1 } = cur;
            const x2 = x1 + config.base,
                y2 = y1 + config.base;

            for (let j = i + 1; j < cards.length; j++) {
              const compare = cards[j];
              // å·²æ¶ˆå®Œå¡ç‰‡å’Œåœ¨å¡æ§½å†…çš„å¡ç‰‡è·³è¿‡
              if (compare.status !== 0 || compare.display) continue;
              const { x, y } = compare;
              if (!(y + config.base <= y1 || y >= y2 || x + config.base <= x1 || x >= x2)) {
                  cur.not = false;
                  break;
              }
            }
          }
        }

        /**
         * å¼€å§‹æ¸¸æˆ
         */
        const handleStart = () => {
          if(data.cards.length) {
            window.alert('æ¸¸æˆä¸­');
            return;
          }
          audio.play();
          init();
        }        
        
        /**
         * é‡ç½®æ¸¸æˆ
         */
        const handleReset = () => {
          // æ¸…ç©ºå·²æœ‰çš„å¡ç‰‡
          data.cards.length = 0;
          data.select.clear();
          init();
          audio.replay();
        }

        /**
         * åˆ‡æ¢å…³å¡
         */
        const handleSwitch = (type) => {
          if(type === 'prev') {
            if(data.level === 1) {
              window.alert('å·²ç»æ˜¯ç¬¬ä¸€å…³äº†');
              return;
            }
            data.level--;
          } else {
            if(data.level === defaultIcons.length) {
              window.alert('å·²ç»æ˜¯æœ€åä¸€å…³äº†');
              return;
            }
            data.level++;
          }
        }

        /**
         * ç‚¹å‡»å¡ç‰‡
         */
        const clickCard = async (item, index) => {
          // å¡æ§½ä¸­çš„å¡ç‰‡ä¸å…è®¸ç‚¹å‡»
          if(item.status === 1) return;

          // æ’­æ”¾ç‚¹å‡»éŸ³ä¹
          audio.rePlayClickBgm();

          const length = selectLength.value;
          const { selectMaxLength } = config;
          if(item.not && length < selectMaxLength) {
            const cards = data.cards;
            const currentCard = cards[index];
            currentCard.status = 1;

            // åˆ·æ–°å¡æ§½ä½ç½®
            await refreshCardPosition(currentCard);
            // åˆ·æ–°è¢«é®æŒ¡å¡ç‰‡
            checkShading();
          };

           // æ ¡éªŒå¡ç‰‡å¡æ§½å¡ç‰‡æ•°é‡é•¿åº¦
          setTimeout(() => {
            if(selectLength.value >= config.selectMaxLength) {
              alert('æ¸¸æˆå¤±è´¥ é‡æ–°å¼€å§‹');
              handleReset();
            }
          }, config.animationTime);

        }

        /**
         * åˆ·æ–°å¡æ§½å¡ç‰‡ä½ç½®
         */
        const refreshCardPosition = (item) => {
          const { x, y } = data.cardSlotInfo;
          const { top, left } = data.containerInfo;

          if (item) {
            // æ˜¯å¦å­˜åœ¨
            const cards = data.select.get(item.icon);
            if (cards) {
              cards.push(item);
              checkSelectQueue(cards);
            } else {
              data.select.set(item.icon, [item]);
            }
          }
          // é‡æ–°åˆ·æ–°ä½ç½®
          let index = 0;
          const poor = (x < left) ? -(left - x) : (x - left);
          data.select.forEach((item) => {
            item.forEach((card) => {
              card.x = index * config.base + poor + config.base / 2;
              card.y = y - top + 12;
              index++;
            });
          });
        }

        /**
         * æ ¡éªŒå¡æ§½ä¸­æ˜¯å¦3ä¸ªç›¸åŒçš„å­˜åœ¨
         */
        const checkSelectQueue = (cards) => {
          if(cards.length === config.maxCount) {
            cards.forEach((item) => {
              item.clear = true;
            })
            
            setTimeout(() => {
              // åˆ é™¤å¡æ§½ä¸­å¡ç‰‡
              data.select.delete(cards[0].icon);
              // åˆ é™¤cardsä¸­çš„å¡ç‰‡ è½¯åˆ é™¤ displayä»£æ›¿
              cards.forEach((item) => {
                item.display = true;
              })
            }, config.animationTime - 100);

            setTimeout(() => {
              // å±æ€§å¡æ§½å¡ç‰‡ä½ç½®
              refreshCardPosition();

              // æ ¡éªŒæ˜¯å¦å¡ç‰‡åˆ—è¡¨æ˜¯å¦è¿˜æœ‰æœªæ¶ˆé™¤çš„å¡ç‰‡
              const hasCards = data.cards.filter((item) => !item.display);
              const level = data.level + 1;
              if(!hasCards.length && level < config.maxLevel) {
                alert(`é€šå…³å•¦, å¼€å§‹ç¬¬${level}å…³`);
                data.level++;
              }
              if (!hasCards.length && level >= config.maxLevel) {
                {
                alert('æ­å–œ ğŸ‰ğŸ‰ æ¸¸æˆé€šå…³å’¯ å³å°†å›åˆ°ç¬¬ä¸€å…³');
                data.level = 1;
              }
              }
            }, config.animationTime + 100);
          }
        }

        const dataRefs = toRefs(data);
        return {
          ...dataRefs,
          config,
          handleStart,
          setContainerStyle,
          setCardStyle,
          setAnimation,
          handleSwitch,
          handleReset,
          clickCard
        }
      }
    }
    Vue.createApp(App).mount('#app');
  </script>
</body>
</html>